system("c:/Users/yx/Dropbox/touchparse/hook_sam.exe")
samsung = 1
sony = 0
sonyz = 0
if(samsung)
{
# samsung
# Step 1: run autohotkey (control AnyBodyCon Script)
# convert to .exe
# setwd("C:/Program Files/AutoHotkey/Compiler/")
# system("Ahk2Exe.exe /in \"c:/Users/yaxuan/Dropbox/touchparse/hook.ahk\"")
system("e:/Dropbox/touchparse/hook.exe")
}else if(sony){
# sony
# Step 1: run autohotkey (control AnyBodyCon Script)
# setwd("C:/Program Files/AutoHotkey/Compiler/")
# system("Ahk2Exe.exe /in \"c:/Users/yaxuan/Dropbox/touchparse/hook_sony.ahk\"")
system("e:/Dropbox/touchparse/hook_sony.exe")
}else{
# sony
# Step 1: run autohotkey (control AnyBodyCon Script)
# setwd("C:/Program Files (x86)/AutoHotkey/Compiler/")
# system("Ahk2Exe.exe /in \"c:/Users/yx/Dropbox/touchparse/hook_sonyz.ahk\"")
system("e:/Dropbox/touchparse/hook_sonyz.exe")
}
samsung = 1
sony = 0
sonyz = 0
if(samsung)
{
# samsung
# Step 1: run autohotkey (control AnyBodyCon Script)
# convert to .exe
# setwd("C:/Program Files/AutoHotkey/Compiler/")
# system("Ahk2Exe.exe /in \"c:/Users/yaxuan/Dropbox/touchparse/hook.ahk\"")
system("e:/Dropbox/touchparse/hook.exe")
}else if(sony){
# sony
# Step 1: run autohotkey (control AnyBodyCon Script)
# setwd("C:/Program Files/AutoHotkey/Compiler/")
# system("Ahk2Exe.exe /in \"c:/Users/yaxuan/Dropbox/touchparse/hook_sony.ahk\"")
system("e:/Dropbox/touchparse/hook_sony.exe")
}else{
# sony
# Step 1: run autohotkey (control AnyBodyCon Script)
# setwd("C:/Program Files (x86)/AutoHotkey/Compiler/")
# system("Ahk2Exe.exe /in \"c:/Users/yx/Dropbox/touchparse/hook_sonyz.ahk\"")
system("e:/Dropbox/touchparse/hook_sonyz.exe")
}
samsung = 1
sony = 0
sonyz = 0
if(samsung)
{
# samsung
# Step 1: run autohotkey (control AnyBodyCon Script)
# convert to .exe
# setwd("C:/Program Files/AutoHotkey/Compiler/")
# system("Ahk2Exe.exe /in \"c:/Users/yaxuan/Dropbox/touchparse/hook.ahk\"")
system("e:/Dropbox/touchparse/hook.exe")
}else if(sony){
# sony
# Step 1: run autohotkey (control AnyBodyCon Script)
# setwd("C:/Program Files/AutoHotkey/Compiler/")
# system("Ahk2Exe.exe /in \"c:/Users/yaxuan/Dropbox/touchparse/hook_sony.ahk\"")
system("e:/Dropbox/touchparse/hook_sony.exe")
}else{
# sony
# Step 1: run autohotkey (control AnyBodyCon Script)
# setwd("C:/Program Files (x86)/AutoHotkey/Compiler/")
# system("Ahk2Exe.exe /in \"c:/Users/yx/Dropbox/touchparse/hook_sonyz.ahk\"")
system("e:/Dropbox/touchparse/hook_sonyz.exe")
}
library(recommenderlab) # package being evaluated
library(ggplot2) # For plots
m <- matrix(sample(c(0,1), 50, replace=TRUE), nrow=5, ncol=10,
dimnames=list(users=paste("u", 1:5, sep=''),
items=paste("i", 1:10, sep='')))
m
## coerce it into a binaryRatingMatrix
b <- as(m, "binaryRatingMatrix")
b
b
as(b, "matrix")
dim(b)
dimnames(b)
rowCounts(b)
colCounts(b)
## plot
image(b)
sample(b,2)
b[1:2,1:5]
as(b, "list")
head(as(b, "data.frame"))
head(getData.frame(b, ratings=FALSE))
## creation from user/item tuples
df <- data.frame(user=c(1,1,2,2,2,3), items=c(1,4,1,2,3,5))
df
b2 <- as(df, "binaryRatingMatrix")
b2
as(b2, "matrix")
data(Jester5k)
## create 90/10 split (known/unknown) for the first 500 users in Jester5k
e <- evaluationScheme(Jester5k[1:500,], method="split", train=0.9,
k=1, given=15)
e
## create a user-based CF recommender using training data
r <- Recommender(getData(e, "train"), "UBCF")
r
data(Jester5k)
## create 90/10 split (known/unknown) for the first 500 users in Jester5k
e <- evaluationScheme(Jester5k[1:500,], method="split", train=0.9,
k=1, given=15)
e
## create a user-based CF recommender using training data
r <- Recommender(getData(e, "train"), "UBCF")
p <- predict(r, getData(e, "known"), type="ratings")
p
data(MSWeb)
## between 5 users
dissimilarity(MSWeb[1:5,], method = "jaccard")
MSWeb[1:5,]
as(MSWeb[1:5,], "matrix")
as.data.frame(MSWeb[1:5,])
as.matrix(MSWeb[1:5,])
similarity(MSWeb[1:5,], method = "jaccard")
install.packages("stats")
install.packages("stats")
install.packages("stats")
install.packages("stats")
install.packages("stats")
install.packages("stats")
install.packages("skmeans")
set.seed(1234)
## Use CLUTO dataset 're0' and the reader for CLUTO sparse matrix
## format in package 'slam'. (In text clustering applications, x will
## often be a DocumentTermMatrix object obtained from package 'tm'.)
x <- slam::read_stm_CLUTO(system.file("cluto", "re0.mat",
package = "skmeans"))
## Which is not really small:
dim(x)
x
hparty <- skmeans(x, 5, control = list(verbose = TRUE))
## Criterion value obtained:
hparty$value
library("skmeans")
hparty <- skmeans(x, 5, control = list(verbose = TRUE))
## Criterion value obtained:
hparty$value
class_ids <- attr(x, "rclass")
table(class_ids, hparty$cluster)
require("cluster")
plot(silhouette(hparty))
sparty <- skmeans(x, 5, m = 1.1,
control = list(nruns = 5, verbose = TRUE))
sparty$value
## (This should be a lower bound for the criterion value of the hard
## partition.)
## Compare the soft and hard partitions:
table(hparty$cluster, sparty$cluster)
## Or equivalently using the high-level accessors from package 'clue':
require("clue")
table(cl_class_ids(hparty), cl_class_ids(sparty))
## Which can also be used for computing agreement/dissimilarity measures
## between the obtained partitions.
cl_agreement(hparty, sparty, "Rand")
## How fuzzy is the obtained soft partition?
cl_fuzziness(sparty)
## And in fact, looking at the membership margins we see that the
## "sureness" of classification is rather high:
summary(cl_margin(sparty))
setwd("E:/Dropbox/workspace/p_recommend_stroke/src")
source("../R.src/common.R")
source("../R.src/my.fig.R")
source("../R.src/my.legend.R")
source("../R.src/legend_col.R")
source("../R.src/rey.f.R")
source("../R.src/yx.common.R")
name.d = c("time", "type", "event", "value")
name.d2 = c("t", "sl", "id", "lv", "x", "y", "prs")
odir <- "../origin data/"
#處理後的log檔
cdir <- "../complete data/"
#遊戲跟其code的列表
gn <- "../gn.txt"
#設定參數
ntect = -9 #設定none detect為-9
time_limit = 60 #game log檔至少要60S以上
gcode = read.table(gn, header=T, sep="\t", as.is=T, encoding="UTF-8") #讀取game列表
p.list=c('1201sub01','1202sub01','1202sub02', '1203sub01', '1205sub01','1205sub02') #設定player列表
gcode = read.table(gn, header=T, sep="\t", as.is=T, encoding="UTF-8") #讀取game列表
gcode
cdir_path = paste(cdir, "d2", sep="")
allsub = list.files(path=cdir_path, full=T)
name.all=list.files(path=cdir_path)
gcode$gc
for(game in gcode$gc){
fn.d3 = paste(cdir, "d3/",  game, ".txt", sep="")
sink(fn.d3)
for(sub in allsub) {
# list all subject files =================
fn.full = list.files(sub, full=T)         #list all the path
fn.part = list.files(sub)                 #list file names only
# find the game log =================
n = grep(game, fn.part)   #回傳fn.part的位置，如果吻合
if(length(n)==0)
next
# read file =================
d2 = read.table(fn.full[n], header=T)
names(d2)<-name.d2 #time, multi-event, event, pos.x, pos.y, press
#clean the record which is in the prev game===============
if(d2$id[1]==ntect){  # if the first record is not a start of actions
act.last=which(d2$id!=ntect)[1]-1
if(is.na(act.last))
stop()
d2 <- d2[-(1:act.last),]
}
#若x,y,prs為ntect(因為資料在上個遊戲)，拿掉data
d2 <- d2[d2$x!=ntect & d2$y!=ntect,]
d2$prs[d2$prs==ntect] <- NA
#if "sum.l>thd.dis" means that the type is belong to "slide"
thd.dis = 48
# To find the id list in each trace
id.list = unique(d2$id)
for(j in id.list)
{
isd = which(d2$id == j)
dx = diff(d2$x[isd])
dy = diff(d2$y[isd])
vec = cbind(dx, dy)
st = d2$t[min(isd)]
et = d2$t[max(isd)]
# Velocity & Speed =======================
part.l = sqrt(dx^2+dy^2)
part.t = diff(d2$t[isd])
sum.l = sum(part.l)
sum.t = diff(range(d2$t[isd]))
if(sum.l < thd.dis){
type="tap"
mean.s = NA
mean.v = NA
sd.v = NA
}else{
type="sld"
mean.s = sum.l/sum.t
part.v = part.l/part.t
mean.v = mean(part.v, na.rm = T)
sd.v = sd(part.v, na.rm = T)
}
# Pressure=========================
mean.prs = mean(d2$prs[isd])
sd.prs = sd(d2$prs[isd], na.rm = T)
# game feature belong to one subject
d3 = c(game, sub, type, sum.l, st, et, sum.t, mean.prs, sd.prs, mean.v, sd.v)
cat(d3, "\n")
}
}
sink()
}
for(game in gcode$gc){
fn.d3 = paste(cdir, "d3/",  game, ".txt", sep="")
d3 = read.table(file = fn.d3)
names(d3) = c("gn", "sub", "type", "sum.l", "st", "et", "sum.t",
"mean.prs", "sd.prs", "mean.v", "sd.v")
sub.list = unique(d3$sub)
fn.d4 = paste(cdir, "d4/",  game, ".txt", sep="")
sink(fn.d4)
for(s in sub.list){
isd = which(d3$sub == s)
t.s = d3$st[min(isd)]
t.e = d3$et[max(isd)]
t.all = t.e-t.s
num.act = len(isd)
frq.act = num.act/t.all
id.tap = which(d3$type[isd]=="tap")
num.tap = len(id.tap)
frq.tap = num.tap/t.all
ratio.tap = num.tap/num.act
dur.tap = mean(d3$sum.t[id.tap], na.rm=T)
id.sld = which(d3$type[isd]=="sld")
num.sld = len(id.sld)
frq.sld = num.sld/t.all
ratio.sld = num.sld/num.act
dis.sld = mean(d3$sum.l[id.sld], na.rm=T)
d4 = c(game, s, t.all, num.act, frq.act,
num.tap, frq.tap, ratio.tap, dur.tap,
num.sld, frq.sld, ratio.sld, dis.sld)
cat(d4, "\n")
}
sink()
}
gcode$gc
game
sub.list
d3$sub
d3
View(`d3`)
d2
View(`d2`)
sub
allsub
name.all
name.allsub=list.files(path=cdir_path)
name.allsub
allsub
fn.full
fn.part
sub
allsub
fn.part
name.allsub
sub
name.allsub[sub]
n
grep(game, fn.part)
game
fn.part
sub
for(game in gcode$gc){
fn.d3 = paste(cdir, "d3/",  game, ".txt", sep="")
sink(fn.d3)
for(sub in 1:len(allsub)) {
# list all subject files =================
fn.full = list.files(allsub[sub], full=T)         #list all the path
fn.part = list.files(allsub[sub])                 #list file names only
# find the game log =================
n = grep(game, fn.part)   #回傳fn.part的位置，如果吻合
if(length(n)==0)
next
# read file =================
d2 = read.table(fn.full[n], header=T)
names(d2)<-name.d2 #time, multi-event, event, pos.x, pos.y, press
#clean the record which is in the prev game===============
if(d2$id[1]==ntect){  # if the first record is not a start of actions
act.last=which(d2$id!=ntect)[1]-1
if(is.na(act.last))
stop()
d2 <- d2[-(1:act.last),]
}
#若x,y,prs為ntect(因為資料在上個遊戲)，拿掉data
d2 <- d2[d2$x!=ntect & d2$y!=ntect,]
d2$prs[d2$prs==ntect] <- NA
#if "sum.l>thd.dis" means that the type is belong to "slide"
thd.dis = 48
# To find the id list in each trace
id.list = unique(d2$id)
for(j in id.list)
{
isd = which(d2$id == j)
dx = diff(d2$x[isd])
dy = diff(d2$y[isd])
vec = cbind(dx, dy)
st = d2$t[min(isd)]
et = d2$t[max(isd)]
# Velocity & Speed =======================
part.l = sqrt(dx^2+dy^2)
part.t = diff(d2$t[isd])
sum.l = sum(part.l)
sum.t = diff(range(d2$t[isd]))
if(sum.l < thd.dis){
type="tap"
mean.s = NA
mean.v = NA
sd.v = NA
}else{
type="sld"
mean.s = sum.l/sum.t
part.v = part.l/part.t
mean.v = mean(part.v, na.rm = T)
sd.v = sd(part.v, na.rm = T)
}
# Pressure=========================
mean.prs = mean(d2$prs[isd])
sd.prs = sd(d2$prs[isd], na.rm = T)
# game feature belong to one subject
d3 = c(game, name.allsub[sub], type, sum.l, st, et, sum.t, mean.prs, sd.prs, mean.v, sd.v)
cat(d3, "\n")
}
}
sink()
}
for(game in gcode$gc){
fn.d3 = paste(cdir, "d3/",  game, ".txt", sep="")
d3 = read.table(file = fn.d3)
names(d3) = c("gn", "sub", "type", "sum.l", "st", "et", "sum.t",
"mean.prs", "sd.prs", "mean.v", "sd.v")
sub.list = unique(d3$sub)
fn.d4 = paste(cdir, "d4/",  game, ".txt", sep="")
sink(fn.d4)
for(s in sub.list){
isd = which(d3$sub == s)
t.s = d3$st[min(isd)]
t.e = d3$et[max(isd)]
t.all = t.e-t.s
num.act = len(isd)
frq.act = num.act/t.all
id.tap = which(d3$type[isd]=="tap")
num.tap = len(id.tap)
frq.tap = num.tap/t.all
ratio.tap = num.tap/num.act
dur.tap = mean(d3$sum.t[id.tap], na.rm=T)
id.sld = which(d3$type[isd]=="sld")
num.sld = len(id.sld)
frq.sld = num.sld/t.all
ratio.sld = num.sld/num.act
dis.sld = mean(d3$sum.l[id.sld], na.rm=T)
d4 = c(game, s, t.all, num.act, frq.act,
num.tap, frq.tap, ratio.tap, dur.tap,
num.sld, frq.sld, ratio.sld, dis.sld)
cat(d4, "\n")
}
sink()
}
fn.d5 = paste(cdir, "d5.txt", sep="")
sink(fn.d5)
for(game in gcode$gc){
fn.d3 = paste(cdir, "d3/",  game, ".txt", sep="")
d3 = read.table(file = fn.d3)
names(d3) = c("gn", "sub", "type", "sum.l", "st", "et", "sum.t",
"mean.prs", "sd.prs", "mean.v", "sd.v")
sub.list = unique(d3$sub)
fn.d4 = paste(cdir, "d4/",  game, ".txt", sep="")
#   sink(fn.d4)
for(s in sub.list){
isd = which(d3$sub == s)
t.s = d3$st[min(isd)]
t.e = d3$et[max(isd)]
t.all = t.e-t.s
num.act = len(isd)
frq.act = num.act/t.all
id.tap = which(d3$type[isd]=="tap")
num.tap = len(id.tap)
frq.tap = num.tap/t.all
ratio.tap = num.tap/num.act
dur.tap = mean(d3$sum.t[id.tap], na.rm=T)
id.sld = which(d3$type[isd]=="sld")
num.sld = len(id.sld)
frq.sld = num.sld/t.all
ratio.sld = num.sld/num.act
dis.sld = mean(d3$sum.l[id.sld], na.rm=T)
d4 = c(game, s, t.all, num.act, frq.act,
num.tap, frq.tap, ratio.tap, dur.tap,
num.sld, frq.sld, ratio.sld, dis.sld)
cat(d4, "\n")
}
#   sink()
}
sink()
